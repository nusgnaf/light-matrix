

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to LightMatrix &mdash; LightMatrix 0.5.0 documentation</title>
    
    <link rel="stylesheet" href="_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LightMatrix 0.5.0 documentation" href="#" />
    <link rel="next" title="Get Started" href="get_started.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
        <div class="headertitle"><a
          href="#">LightMatrix 0.5.0 documentation</a></div>
        <div class="rel">
          <a href="get_started.html" title="Get Started"
             accesskey="N">next</a> |
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="welcome-to-lightmatrix">
<h1>Welcome to LightMatrix<a class="headerlink" href="#welcome-to-lightmatrix" title="Permalink to this headline">¶</a></h1>
<p><strong>LightMatrix</strong> is a C++ template library for matrix computation, which provides a unique combination of <em>design-time productivity</em> and <em>run-time performance</em>.
With this library, user can write codes using a set of friendly APIs (just like in MATLAB). These codes will then be transparently translated to highly optimized routines (at compile-time), through a meta-programming engine.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Relying a carefully designed core framework, LightMatrix has a series of nice properties. Here is a brief summary:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#easy-to-use"><em>LightMatrix is easy to use</em></a>: one can perform computation easily using natural expressions</li>
<li><a class="reference internal" href="#efficient"><em>LightMatrix is efficient</em></a>: high level codes will be mapped to tight loops of highly optimized SIMD instructions through meta-programming. No temporary matrices will be created in most cases.</li>
<li><a class="reference internal" href="#convenient"><em>LightMatrix is convenient</em></a>: it supports various ways to access elements and sub parts of a matrix.</li>
<li><a class="reference internal" href="#versatile"><em>LightMatrix is versatile</em></a>: it offers a broad range of functions out of box, which range from elementary functions, matrix reduction, to linear algebra.</li>
<li><a class="reference internal" href="#interoperable"><em>LightMatrix works nicely with other libraries</em></a>: it can directly work on external memories (without copying). Interfaces to work with STL vectors and MATLAB arrays are provided.</li>
<li><a class="reference internal" href="#kernel-support"><em>LightMatrix supports kernel-based computation</em></a>: it has elegant syntax to define kernels and apply them to matrices in an element-wise manner. This provides a very efficient way for multi-input multi-output computation.</li>
<li><a class="reference internal" href="#extensible"><em>LightMatrix is extensible</em></a>: one can easily introduce new matrix expressions and evaluation methods.</li>
<li><a class="reference internal" href="#light-weight"><em>LightMatrix is light-weight</em></a>: it is a pure header library, and it does not rely on third-party libraries such as <em>BOOST</em>.</li>
<li><a class="reference internal" href="#reliable"><em>LightMatrix is reliable</em></a>: quality assured through extensive unit testing.</li>
</ul>
</div></blockquote>
<p><strong>Below are some specific examples/explanations to illustrate these features.</strong></p>
<div class="section" id="lightmatrix-is-easy-to-use">
<span id="easy-to-use"></span><h3><strong>LightMatrix</strong> is easy to use<a class="headerlink" href="#lightmatrix-is-easy-to-use" title="Permalink to this headline">¶</a></h3>
<p>You can easily make matrices and perform computation using matrix expressions.</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">lmat</span><span class="p">;</span>

<span class="c1">// generate a 2-by-3 matrix by inserting elements in row-major order</span>
<span class="n">dense_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">rm_</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">}));</span>

<span class="c1">// generate a matrix by copying elements from a memory source</span>
<span class="kt">double</span> <span class="n">src</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mf">6.</span><span class="p">,</span> <span class="mf">7.</span><span class="p">,</span> <span class="mf">8.</span><span class="p">};</span>
<span class="n">dense_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">copy_from</span><span class="p">(</span><span class="n">src</span><span class="p">));</span>

<span class="c1">// do some computation</span>
<span class="n">a</span> <span class="o">+=</span> <span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="lightmatrix-is-efficient">
<span id="efficient"></span><h3><strong>LightMatrix</strong> is efficient<a class="headerlink" href="#lightmatrix-is-efficient" title="Permalink to this headline">¶</a></h3>
<p>When AVX is enabled, the last statement above would be translated transparently at compile time to something like the following: (<em>note: it also supports SSE</em>)</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">v1</span> <span class="o">=</span> <span class="n">_mm256_set1_pd</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">index_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">nelems</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">va</span> <span class="o">=</span> <span class="n">_mm256_load_pd</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">ptr_data</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">vb</span> <span class="o">=</span> <span class="n">_mm256_load_pd</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">ptr_data</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">__svml_exp4</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">__svml_log4</span><span class="p">(</span><span class="n">_mm256_add_pd</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">v1</span><span class="p">));</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_mm256_add_pd</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>
        <span class="n">_mm256_store_pd</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">ptr_data</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>The performance is comparable to hand-optimized SIMD codes. (Node: <tt class="docutils literal"><span class="pre">__svml_exp4</span></tt> and <tt class="docutils literal"><span class="pre">__svml_log4</span></tt> are routines to compute exp and log on AVX vectors.)
When explicitly requested, it can also generate multi-threaded codes using OpenMP.</p>
</div>
<div class="section" id="lightmatrix-is-convenient">
<span id="convenient"></span><h3><strong>LightMatrix</strong> is convenient<a class="headerlink" href="#lightmatrix-is-convenient" title="Permalink to this headline">¶</a></h3>
<p>LightMatrix supports a variety of convenient ways to access to elements and parts of a matrix. You may access individual elements using either subscripts or linear indices:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Let a be a matrix</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>   <span class="c1">// access the element at i-th row and j-th column</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>    <span class="c1">// access the idx-th element over the entire matrix</span>
</pre></div>
</div>
</div></blockquote>
<p>You may access a row or a column of a matrix</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">column</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>   <span class="c1">// c is a view of the j-th column</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>      <span class="c1">// r is a view of the i-th row</span>
</pre></div>
</div>
</div></blockquote>
<p>Miss MATLAB&#8217;s colon syntax? LightMatrix provides similar ways for you to access parts of a matrix</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// get a view of a sub-matrix</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">colon</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">),</span> <span class="n">colon</span><span class="p">(</span><span class="n">j0</span><span class="p">,</span> <span class="n">j1</span><span class="p">));</span>

<span class="c1">// get a view of n consecutive columns from the j-th one</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="p">(</span><span class="n">whole</span><span class="p">(),</span> <span class="n">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">));</span>

<span class="c1">// select a certain set of rows</span>
<span class="n">si</span> <span class="o">=</span> <span class="n">dense_col</span><span class="o">&lt;</span><span class="n">index_t</span><span class="o">&gt;</span><span class="p">({</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">});</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">select_rows</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">si</span><span class="p">);</span>

<span class="c1">// add a value to each element on the diagonal</span>
<span class="n">a</span><span class="p">.</span><span class="n">diag</span><span class="p">()</span> <span class="o">+=</span> <span class="mf">2.0</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="lightmatrix-is-versatile">
<span id="versatile"></span><h3><strong>LightMatrix</strong> is versatile<a class="headerlink" href="#lightmatrix-is-versatile" title="Permalink to this headline">¶</a></h3>
<p>It comprises a broad range of functions for various kinds of computation (out of box):</p>
<ul>
<li><p class="first">matrix manipulation, such as vector repeating and matrix transposition</p>
</li>
<li><p class="first">element-wise arithmetics, logical operations, comparison, and conditional selection</p>
</li>
<li><p class="first">element-wise elemental functions (including all those in C99/C++11 math)</p>
</li>
<li><p class="first">reduction functions (including sum, mean, maximum, minimum, minmax, norms, etc) in three forms: whole-matrix, column-wise, and row-wise reduction.</p>
</li>
<li><p class="first">linear algebraic computation:</p>
<blockquote>
<div><ul class="simple">
<li>matrix-vector and matrix-matrix multiplication</li>
<li>matrix factorization: LU, QR, and Cholesky</li>
<li>eigenvalue and eigenvector</li>
<li>singular value decomposition</li>
<li>solving linear equations and least square problems</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">random matrices from different distributions</p>
</li>
</ul>
</div>
<div class="section" id="lightmatrix-works-nicely-with-other-libraries">
<span id="interoperable"></span><h3><strong>LightMatrix</strong> works nicely with other libraries<a class="headerlink" href="#lightmatrix-works-nicely-with-other-libraries" title="Permalink to this headline">¶</a></h3>
<p>Practical applications often involve multiple libraries. We realize this and consider interoperability with other libraries as an essential feature from the very beginning.</p>
<p>The matrix class exposes the raw data pointer, so that you can use other functions, in particular those in C libraries, to process the data in a matrix, as</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">a</span><span class="p">.</span><span class="n">ptr_data</span><span class="p">();</span>  <span class="c1">// returns the pointer to the base address</span>
<span class="n">a</span><span class="p">.</span><span class="n">ptr_col</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>  <span class="c1">// returns the pointer to the base of the j-th column</span>
</pre></div>
</div>
</div></blockquote>
<p>You may also construct a matrix directly on external memory blocks:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// let p be a pointer to some contiguous memory region</span>
<span class="n">ref_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>  <span class="c1">// construct an m-by-n matrix directly on p</span>

<span class="c1">// when the stride between consecutive columns is stride (instead of m)</span>
<span class="n">ref_block</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">stride</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>LightMatrix works well with STL vector and MATLAB mxArray</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// directly adapts std::vector to a LightMatrix column vector (no copying)</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">dense_col</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">as_col</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="o">*</span> <span class="mf">2.0</span><span class="p">);</span>

<span class="c1">// creates a LightMatrix view on a MATLAB array (handy for writing mex)</span>
<span class="k">const</span> <span class="n">mxArray</span> <span class="o">*</span><span class="n">mx</span> <span class="o">=</span> <span class="n">prhs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">ref_matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">view2d</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mx</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="lightmatrix-supports-kernel-based-computation">
<span id="kernel-support"></span><h3><strong>LightMatrix</strong> supports <em>kernel-based</em> computation<a class="headerlink" href="#lightmatrix-supports-kernel-based-computation" title="Permalink to this headline">¶</a></h3>
<p>In complex numerical computation that involves multiple inputs and outputs, kernel-based computation is often more efficient than matrix expressions.</p>
<p>Suppose you want to do the computation as expressed by the following matrix expressions:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="n">u</span> <span class="o">=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>But then <tt class="docutils literal"><span class="pre">sqr(a</span> <span class="pre">+</span> <span class="pre">b)</span></tt> and <tt class="docutils literal"><span class="pre">sqr(a</span> <span class="pre">-</span> <span class="pre">b)</span></tt> are respectively calculated twice. Whereas one can temporarily store the the intermediate results, this way demands more memory and requires scanning each matrix more than once. The more optimal way is to apply a multi-input-multi-output kernel, as</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// define a kernel function</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">my_fun</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">);</span>
        <span class="n">T</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">sqr</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">);</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t2</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">t1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// wrap it into a kernel</span>
<span class="n">LMAT_DEF_KERNEL_2in_2out</span><span class="p">(</span> <span class="n">my_kernel</span><span class="p">,</span> <span class="n">my_fun</span> <span class="p">)</span>

<span class="c1">// apply the kernel in an element-wise way to matrices</span>
<span class="n">ewise</span><span class="p">(</span><span class="n">my_kernel</span><span class="p">())(</span><span class="n">in_</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">in_</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">out_</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">out_</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p>LightMatrix will translate this (at compile-time) into tight loops of SIMD instructions, without creating any temporary matrices.</p>
</div>
<div class="section" id="lightmatrix-is-extensible">
<span id="extensible"></span><h3><strong>LightMatrix</strong> is extensible<a class="headerlink" href="#lightmatrix-is-extensible" title="Permalink to this headline">¶</a></h3>
<p>LightMatrix is designed with extensibility in mind. Developers can easily extend the library by introducing new matrix expressions or even new evaluation paradigms, following the <a class="reference internal" href="dev_guide.html"><em>Developer Guide</em></a>.</p>
</div>
<div class="section" id="lightmatrix-is-light-weight">
<span id="light-weight"></span><h3><strong>LightMatrix</strong> is light-weight<a class="headerlink" href="#lightmatrix-is-light-weight" title="Permalink to this headline">¶</a></h3>
<p>LightMatrix is a <em>pure header</em> library. To use it, just check it out from <a class="reference external" href="https://github.com/lindahua/light-matrix/">GitHub</a>, and include the relevant headers in your code.</p>
<p>Note that linking with third-party libraries is needed for some functions. For example, you may have to link your code to BLAS/LAPACK or MKL when using the linear algebra module.</p>
</div>
<div class="section" id="lightmatrix-is-reliable">
<span id="reliable"></span><h3><strong>LightMatrix</strong> is reliable<a class="headerlink" href="#lightmatrix-is-reliable" title="Permalink to this headline">¶</a></h3>
<p>The quality of the library is assured through thousands of unit-test cases.</p>
</div>
</div>
</div>
<div class="section" id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="get_started.html">Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev_guide.html">Developer Guide</a></li>
</ul>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="get_started.html">Get Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="basics.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="advanced.html">Advanced Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="dev_guide.html">Developer Guide</a></li>
</ul>

          <h3 style="margin-top: 1.5em;">Search</h3>
          <form class="search" action="search.html" method="get">
            <input type="text" name="q" />
            <input type="submit" value="Go" />
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
          </form>
          <p class="searchtip" style="font-size: 90%">
            Enter search terms or a module, class or function name.
          </p>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <a href="get_started.html" title="Get Started"
             >next</a> |
          <a href="genindex.html" title="General Index"
             >index</a>
            <br/>
            <a href="_sources/index.txt"
               rel="nofollow">Show Source</a>
        </div>

        <div class="right">
          
    <div class="footer">
        &copy; Copyright 2013, Dahua Lin.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>